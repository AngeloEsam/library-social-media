(()=>{var s={617:(s,e,t)=>{const o=t(596),a=(t(702),t(829)),r=t(729);let{promisify:n}=t(23);const i=t(355),d=t(749),c=t(685);e.signup=async(s,e)=>{try{const{name:t,email:n,password:i,confirmPassword:d}=s.body;if(console.log(s.body),!(t&&n&&i&&d))return e.status(400).json({message:"All fields are required"});if(await o.findOne({email:n}))return e.status(409).json("email already exist");if(i!==d)return e.status(400).json({message:"Passwords do not match"});const c=await r.hash(i,10),u=await o.create({name:t,email:n,password:c,confirmPassword:c}),l=a.sign({data:{email:u.email,id:u._id,name:u.name,role:u.role}},process.env.SECRET_KEY,{expiresIn:"10h"});e.cookie("token",l,{httpOnly:!0}).status(201).json(u)}catch(s){e.status(400).json({message:"Invalid credentials",error:s})}},e.login=async(s,e)=>{try{const{email:t,password:n}=s.body;if(!t||!n)return e.status(400).json({msg:"Please enter email and password"});const i=await o.findOne({email:t}).select("+password").populate(["favouriteBooks","savedPosts","posts","followers","following"]);if(!i)return e.status(401).json({message:"invalid email or password"});if(!await r.compare(n,i.password))return e.status(401).json({msg:"Invalid email or password"});i.loginTimestamps.push(new Date),await i.save();const d=a.sign({data:{email:i.email,id:i._id,name:i.name,role:i.role}},process.env.SECRET_KEY,{expiresIn:"12h"});e.cookie("token",d,{httpOnly:!0}).status(200).json({user:i})}catch(s){console.log(s),e.status(400).json({message:"Invalid credentials",error:s})}},e.logout=async(s,e)=>{e.clearCookie("token").status(200).json({message:"Logged out successfully"})},e.forgotPassword=async(s,e)=>{const t=await o.findOne({email:s.body.email});if(!t)return e.status(400).json({msg:"there is no user with that email "});const a=t.createPasswordResetToken();await t.save({validateBeforeSave:!1});const r=`Forgot your password? Submit with your new password to: ${s.protocol}://localhost:5173/resetPassword/${a}.\nIf you didn't forget your password, please ignore this email!`;try{await i({email:t.email,subject:"Your password reset token (valid for 10 min)",message:r}),e.status(200).json({status:"success",message:"Token sent to email!"})}catch(s){return t.passwordResetToken=void 0,t.passwordResetExpires=void 0,await t.save({validateBeforeSave:!1}),e.status(400).json({message:"There was an error sending the email. Try again!"})}},e.resetPassword=async(s,e)=>{try{const t=d.createHash("sha256").update(s.params.token).digest("hex"),n=await o.findOne({passwordResetToken:t,passwordResetExpires:{$gt:Date.now()}});if(!n)return e.json({message:"Token is invalid or expired"});s.body.password===s.body.confirmPassword&&(n.password=await r.hash(s.body.password,10),n.confirmPassword=await r.hash(s.body.confirmPassword,10),n.passwordResetToken=void 0,n.passwordResetExpires=void 0,await n.save());const i=a.sign({data:{email:n.email,id:n._id,name:n.name}},process.env.SECRET_KEY);e.cookie("token",i,{httpOnly:!0}).status(200).json({user:n})}catch(s){e.status(400).json({message:"Invalid credentials",error:s})}},e.updatePassword=async(s,e)=>{try{const t=await o.findById(s.user.id).select("+password");if(console.log(t.password),console.log(s.body.currentPassword,s.body.password),!await r.compare(s.body.currentPassword,t.password))return e.status(400).json({message:"password incorrect"});t.password=s.body.password,t.passwordConfirm=s.body.passwordConfirm,await t.save(),e.status(200).json({user:t})}catch(s){console.log("No"),e.status(400).json({error:s})}},e.googleAuth=async(s,e,t)=>{const{access_token:r}=s.body;c(`https://www.googleapis.com/oauth2/v3/userinfo?access_token=${r}`,(async(s,t,r)=>{if(s||200!=t.statusCode)e.status(t.statusCode).json({error:r});else{const{email:s,name:t,picture:n}=JSON.parse(r);console.log(JSON.parse(r));let i=await o.findOne({email:s});i||(i=await o.create({email:s,name:t,photo:n})),console.log(i);const d=a.sign({data:{email:i.email,id:i._id,name:i.name,role:i.role}},process.env.SECRET_KEY,{expiresIn:"12h"});e.cookie("token",d,{httpOnly:!0}).status(200).json({user:i})}}))},e.auth=async(s,e,t)=>{try{const{token:o}=s.cookies;if(!o)return e.status(404).json({message:"please login"});let{data:r}=await n(a.verify)(o,process.env.SECRET_KEY);s.user={...r},s.user.role=r.role,t()}catch(s){e.status(400).json({error:s})}},e.restrictTo=(...s)=>(e,t,o)=>{if(!s.includes(e.user.role))return t.status(401).json({message:"You are not authorized to view this resource"});o()},e.getLoginStatistics=async()=>{try{const s=await o.find({},"loginTimestamps"),e=Array(7).fill(0);return s.forEach((s=>{s.loginTimestamps.forEach((s=>{const t=s.getDay();e[t]++}))})),["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"].map(((s,t)=>({day:s,count:e[t]})))}catch(s){console.error("Error retrieving login statistics:",s)}},e.getRegistrationStatistics=async()=>{try{const s=await o.find({},"createdAt"),e=Array(7).fill(0);return s.forEach((s=>{const t=s.createdAt.getDay();e[t]++})),["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"].map(((s,t)=>({day:s,count:e[t]})))}catch(s){console.error("Error retrieving registration statistics:",s)}}},284:(s,e,t)=>{const o=t(536);createAuthor=async(s,e)=>{const{name:t,description:a,dateOfBirth:r,country:n}=s.body;try{const s=new o({name:t,description:a,dateOfBirth:r,country:n});await s.save(),e.status(201).json({message:"Added Successfully",Data:s})}catch(s){e.status(500).json({message:s.message})}},s.exports={getAuthor:async(s,e)=>{try{const s=await o.find({}).sort({createdAt:-1}).populate("books");e.status(200).json({message:"success",Data:s})}catch(s){e.status(500).json({message:s.message})}},createAuthor,deleteAuthor:async(s,e)=>{try{const{authorId:t}=s.params;if(!await o.findByIdAndDelete(t))return e.status(404).json({message:"Author not found"});e.status(200).json({message:"Author deleted successfully"})}catch(s){e.status(500).json({message:err.message})}},getSingleAuthor:async(s,e)=>{try{const{authorId:t}=s.params,a=await o.findById(t).populate("books");if(!a)return e.status(404).json({message:"Author not found"});e.status(200).json(a)}catch(s){e.status(500).json({message:s.message})}},searchByName:async(s,e)=>{try{const{name:t}=s.query,a=await o.find({name:t});e.status(200).json(a)}catch(s){e.status(500).json({message:s.message})}},updateAuthor:async(s,e)=>{try{const{authorId:t}=s.params,{name:a,country:r,dateOfBirth:n,description:i}=s.body;console.log(n);const d=await o.findByIdAndUpdate(t,{name:a,country:r,dateOfBirth:n,description:i},{new:!0});d||e.status(404).json("No author with this Id found."),e.status(200).json({Data:d})}catch(s){e.status(500).json("Error updating the Author")}}}},818:(s,e,t)=>{const o=t(878),a=t(596),r=t(536);s.exports={getAllBook:async(s,e)=>{try{const s=await o.find({}).populate(["authorId","ratings"]);e.status(200).json({message:"success",Data:s})}catch(s){e.status(500).json({message:s.message})}},searchByCategory:async(s,e)=>{try{const{category:t}=s.query,a=await o.find({category:t});e.status(200).json(a)}catch(s){return e.status(500).json({message:s.message})}},addBook:async(s,e)=>{try{const t=s.files;let a="",n="";t&&t.Pdf&&(a=t.Pdf[0].filename),t&&t.cover&&(n=t.cover[0].filename);const{title:i,description:d,category:c,authorId:u}=s.body;if(!(i&&d&&c&&u))return e.status(400).json({message:"Title, description, category, and authorId are required fields."});if(!await r.findById(u))return e.status(404).json({message:"Author not found."});const l=await o.create({authorId:u,title:i,description:d,category:c,Pdf:a,cover:n});await r.findByIdAndUpdate(u,{$push:{books:l._id}},{new:!0,useFindAndModify:!1}),e.status(200).json({message:"Added successfully",data:l})}catch(s){e.status(500).json({message:s.message})}},updateBook:async(s,e)=>{try{const{id:t}=s.params,a=s.files;let r={};a&&a.Pdf&&(r.Pdf=a.Pdf[0].filename),a&&a.cover&&(r.cover=a.cover[0].filename);const{title:n,description:i,category:d}=s.body;a&&a.cover&&(r.cover=a.cover[0].filename);const c=await o.findByIdAndUpdate(t,{title:n,description:i,category:d,...r},{new:!0});if(!c)return e.status(404).json({message:"Book not found with id"});e.status(200).json({message:"Update successful",data:c})}catch(s){e.status(500).json({message:s.message})}},deleteBook:async(s,e)=>{try{const{id:t}=s.params;if(!await o.findByIdAndDelete(t))return e.status(404).json({message:"Book not found with id"});e.json({message:"Deleted successfully"})}catch(s){e.status(500).json({message:s.message})}},getSingleBook:async(s,e)=>{try{const{id:t}=s.params,a=await o.findById(t).populate(["authorId","ratings"]);e.status(200).json({message:"get success",data:a})}catch(s){e.status(500).json({message:s.message})}},searchByTitle:async(s,e)=>{try{const{title:t}=s.query;if(!t)return e.status(400).json({message:"Title parameter is required"});const a=await o.find({title:{$regex:new RegExp(t,"i")}});e.status(200).json(a)}catch(s){return e.status(500).json({message:s.message})}},addFavoriteBook:async(s,e)=>{try{const{userId:t,bookId:r}=s.params;if(!t||!r)return e.status(400).json({message:"User ID and Book ID are required."});if(!await o.findById(r))return e.status(404).json({message:"Book not found."});const n=await a.findByIdAndUpdate(t,{$addToSet:{favouriteBooks:r}},{new:!0});if(!n)return e.status(404).json({message:"User not found."});e.status(200).json({message:"Book added to favorites.",data:n})}catch(s){e.status(500).json({message:s.message})}},removeFavoriteBook:async(s,e)=>{try{const{userId:t,bookId:o}=s.params;if(!t||!o)return e.status(400).json({message:"User ID and Book ID are required."});const r=await a.findByIdAndUpdate(t,{$pull:{favouriteBooks:o}},{new:!0});if(!r)return e.status(404).json({message:"User not found."});e.status(200).json({message:"Book removed from favorites.",data:r})}catch(s){e.status(500).json({message:s.message})}},getAllCategory:async(s,e)=>{try{const s=await o.distinct("category");e.status(200).json({message:"success",data:s})}catch(s){e.status(500).json({message:s.message})}}}},474:(s,e,t)=>{const o=t(424),a=t(395),{createNotification:r}=(t(37),t(744)),n=t(596);e.createComment=async(s,e)=>{try{const{userId:t,description:i,postId:d}=s.body,c=await o.create({userId:t,description:i,postId:d});await a.findByIdAndUpdate(d,{$push:{comments:c._id}});const u=await a.findById(d);console.log(u);const l=await n.findById(t).select("name");if(!l)return e.status(404).json({message:"User not found"});const m=l.name,p=u.userId;t!==p.toString()&&await r(t,p,"comment",`${m} commented on your post`),e.status(201).json(c)}catch(s){e.status(500).json({error:s.message})}},e.getAllComments=async(s,e)=>{try{const s=await o.find();console.log(s),e.status(200).json(s)}catch(s){e.status(500).json({error:s.message})}},e.getCommentsByPostId=async(s,e)=>{try{const{postId:t}=s.params,a=await o.find({postId:t}).populate("userId","username");e.status(200).json(a)}catch(s){e.status(500).json({error:s.message})}},e.updateComment=async(s,e)=>{try{const{commentId:t}=s.params,{description:a}=s.body,r=await o.findByIdAndUpdate(t,{description:a},{new:!0});if(!r)return e.status(404).json({error:"Comment not found"});e.status(200).json(r)}catch(s){e.status(500).json({error:s.message})}},e.deleteComment=async(s,e)=>{try{const{commentId:t}=s.params,r=await o.findByIdAndDelete(t);if(!r)return e.status(404).json({error:"Comment not found"});await a.findByIdAndUpdate(r.postId,{$pull:{comments:r._id}}),e.status(200).json({message:"Comment deleted successfully"})}catch(s){e.status(500).json({error:s.message})}},e.likeComment=async(s,e)=>{try{const{commentId:t}=s.params,{userId:a}=s.body;if(!await o.findByIdAndUpdate(t,{$addToSet:{likes:a}},{new:!0}))return e.status(404).json({error:"Comment not found"});const i=(await o.findById(t)).userId;console.log(i);const d=await n.findById(a).select("name");if(!d)return e.status(404).json({message:"User not found"});const c=d.name;a!==i.toString()&&await r(a,i,"like",`${c} liked your comment`),e.status(200).json({message:"Comment liked successfully"})}catch(s){e.status(500).json({error:s.message})}},e.unlikeComment=async(s,e)=>{try{const{commentId:t}=s.params,{userId:a}=s.body,r=await o.findByIdAndUpdate(t,{$pull:{likes:a}},{new:!0});if(!r)return e.status(404).json({error:"Comment not found"});console.log(r),e.status(200).json({message:"Comment unliked successfully",updatedComment:r})}catch(s){e.status(500).json({error:s.message})}}},744:(s,e,t)=>{const o=t(200),a=t(596);let r;s.exports={initializeSocket:s=>{r=s},getNotificationsForUser:async(s,e)=>{const{userId:t}=s.params,{page:a=1,limit:r=10}=s.query;try{const s=await o.find({receiver:t}).sort({createdAt:-1}).skip((a-1)*r).limit(Number(r));e.json(s)}catch(s){e.status(500).json({message:"Error fetching notifications"})}},markNotificationsAsRead:async(s,e)=>{try{await o.updateMany({receiver:s.params.userId,isRead:!1},{isRead:!0}),e.json({message:"Notifications marked as read"})}catch(s){e.status(500).json({message:s.message})}},createNotification:async(s,e,t,n)=>{try{const i=new o({sender:s,receiver:e,type:t,message:n});await i.save(),r&&(console.log(i,"sent"),r.to(e).emit("newNotification",i)),await a.findByIdAndUpdate(e,{$push:{notifications:i._id}}),console.log("Notification created successfully")}catch(s){console.error("Error creating notification:",s)}},deleteNotificationForUser:async(s,e)=>{try{const t=s.params.notificationId,r=s.params.userId;await a.findByIdAndUpdate(r,{$pull:{notifications:t}}),await o.findByIdAndDelete(t),e.json({message:"Notification deleted successfully"})}catch(s){e.status(500).json({message:s.message})}}}},117:(s,e,t)=>{const o=t(395),a=t(596),{createNotification:r}=t(744);e.createPost=async(s,e)=>{const{description:t,type:n,book:i,rating:d}=s.body,c=s.file?s.file.filename:"";try{if(console.log("Authenticated user:",s.user),!s.user||!s.user.id)return e.status(400).json({message:"User not authenticated"});const u={userId:s.user.id,type:n,imageURL:c,description:t};i&&(u.book=i),d&&(u.rating=d);const l=new o(u),m=await l.save(),p=await a.findById(s.user.id).select("name followers posts");p.posts.push(m._id),await p.save();const g=p.name,y=p.followers;for(const e of y)try{await r(s.user.id,e,"new_post",`${g} has posted a new post`),console.log(`Notification sent to followerId: ${e}`)}catch(s){console.error(`Failed to send notification to followerId: ${e}`,s)}e.status(201).json(m)}catch(s){e.status(400).json({message:s.message})}},e.getAllPosts=async(s,e)=>{try{const s=await o.find().sort({createdAt:-1}).populate(["likes","userId","comments"]).populate({path:"comments",populate:{path:"userId"}});e.status(200).json(s)}catch(s){e.status(500).json({message:s.message})}},e.getTwentyPostForPage=async(s,e)=>{try{const t=parseInt(s.query.page)||1,a=parseInt(s.query.limit)||20,r=(t-1)*a,n=await o.find().sort({createdAt:-1}).skip(r).limit(a).populate(["likes","userId","comments"]).populate({path:"comments",populate:{path:"userId"}}),i=await o.countDocuments(),d=Math.ceil(i/a);e.status(200).json({posts:n,totalPages:d,currentPage:t,totalPosts:i})}catch(s){e.status(500).json({message:s.message})}},e.getPostById=async(s,e)=>{try{const t=await o.findById(s.params.id).populate([{path:"comments",populate:[{path:"userId"}]},"likes","userId"]);if(!t)return e.status(404).json({message:"Post not found"});e.status(200).json(t)}catch(s){e.status(500).json({message:s.message})}},e.getUserPosts=async(s,e)=>{try{const t=await o.find({userId:s.params.id}).populate([{path:"comments",populate:[{path:"userId"}]},"likes","userId"]);if(!t)return e.status(404).json({message:"Post not found"});e.status(200).json(t)}catch(s){e.status(500).json({message:s.message})}},e.updatePost=async(s,e)=>{try{const{description:t}=s.body;let a="";null!=s.file&&(a=s.file.filename);const r=await o.findByIdAndUpdate(s.params.id,{description:t,photo:a},{new:!0});if(!r)return e.status(404).json({message:"Post not found"});e.status(200).json(r)}catch(s){e.status(400).json({message:s.message})}},e.deletePost=async(s,e)=>{try{if(!await o.findByIdAndDelete(s.params.id))return e.status(404).json({message:"Post not found"});e.status(200).json({message:"Post deleted successfully"})}catch(s){e.status(500).json({message:s.message})}},e.updatePost=async(s,e)=>{const{userId:t,description:a,type:r,book:n,rating:i}=s.body,d=s.file?s.file.filename:"";try{const c=await o.findByIdAndUpdate(s.params.id,{userId:t,description:a,type:r,imageURL:d,book:n,rating:i},{new:!0});if(!c)return e.status(404).json({message:"Post not found"});e.status(200).json(c)}catch(s){e.status(400).json({message:s.message})}},e.likePost=async(s,e)=>{try{const t=await o.findById(s.params.postId);if(!t)return e.status(404).json({message:"Post not found"});if(t.likes.includes(s.params.userId))e.status(400).json({message:"User already liked this post"});else{t.likes.push(s.params.userId),await t.save();const o=await a.findById(s.params.userId);if(!o)return e.status(404).json({message:"User not found"});console.log("Sender ID:",s.params.userId),console.log("Receiver ID (Post Owner):",t.userId),s.params.userId!==t.userId.toString()&&await r(s.params.userId,t.userId,"like",`${o.name} liked your post`),e.status(200).json({message:"Post liked"})}}catch(s){e.status(500).json({message:s.message})}},e.dislikePost=async(s,e)=>{try{const{postId:t,userId:a}=s.params,r=await o.findById(t);if(!r)return e.status(404).json({message:"Post not found"});if(!r.likes.includes(a))return e.status(400).json({message:"User has not liked this post"});r.likes=r.likes.filter((s=>s.toString()!==a)),await r.save(),e.status(200).json({message:"Post disliked successfully"})}catch(s){e.status(500).json({message:s.message})}},e.savePost=async(s,e)=>{try{const{userId:t,postId:n}=s.params;if(!t||!n)return e.status(400).json({message:"User ID and Post ID are required."});const i=await o.findById(n);if(!i)return e.status(404).json({message:"Post not found."});const d=await a.findByIdAndUpdate(t,{$addToSet:{savedPosts:n}},{new:!0});if(!d)return e.status(404).json({message:"User not found."});const c=await a.findById(t);if(!c)return e.status(404).json({message:"User not found"});t!==i.userId.toString()&&await r(t,i.userId,"save",`${c.name} saved your post`),e.status(200).json({message:"Post added to user's posts.",data:d})}catch(s){e.status(500).json({message:s.message})}},e.unSavePost=async(s,e)=>{try{const{userId:t,postId:o}=s.params;if(!t||!o)return e.status(400).json({message:"User ID and Post ID are required."});const r=await a.findByIdAndUpdate(t,{$pull:{savedPosts:o}},{new:!0});if(!r)return e.status(404).json({message:"User not found."});e.status(200).json({message:"Post removed from favorites.",data:r})}catch(s){e.status(500).json({message:s.message})}},e.getTwentyPostForPage=async(s,e)=>{try{const t=parseInt(s.query.page)||1,a=parseInt(s.query.limit)||20,r=await o.find().sort({createdAt:-1}).limit(a*t).populate(["likes","userId","comments"]).populate({path:"comments",populate:{path:"userId"}}),n=await o.countDocuments(),i=Math.ceil(n/a);e.status(200).json({posts:r,totalPages:i,currentPage:t,totalPosts:n})}catch(s){e.status(500).json({message:s.message})}}},730:(s,e,t)=>{const o=t(438),a=t(878),r=t(596);s.exports={addRating:async(s,e)=>{const{userId:t,bookId:n}=s.params,{rating:i,review:d}=s.body;try{const s=await a.findById(n),c=await r.findById(t);if(!s||!c)return e.status(404).json({error:"Book or User not found"});const u=new o({book:n,user:t,rating:i,review:d});await u.save(),e.status(201).json({message:"Rating added successfully",rating:u})}catch(s){console.error("Error adding rating:",s),e.status(500).json({error:"Internal server error"})}},getFirstFiveReviews:async(s,e)=>{const t=s.params.id;try{const s=await o.find({book:t}).sort({createdAt:-1}).limit(5).populate("user","_id name photo").exec();e.status(200).json({reviews:s})}catch(s){console.error("Error fetching first 5 reviews:",s),e.status(500).json({error:"Internal server error"})}},getAllReviews:async(s,e)=>{const t=s.params.id;try{const s=await o.find({book:t}).populate("user","_id name photo").exec();console.log(s),e.status(200).json({reviews:s})}catch(s){console.error("Error fetching all reviews:",s),e.status(500).json({error:"Internal server error"})}},deleteReview:async(s,e)=>{try{const{userId:t,reviewId:a}=s.params,r=await o.findById(a);if(!r)return e.status(404).json({message:"Review not found"});if(r.user.toString()!==t)return e.status(403).json({message:"User not authorized to delete this review"});await o.deleteOne({_id:a}),e.status(200).json({message:"Review deleted successfully"})}catch(s){e.status(500).json({message:"Server error",error:s})}}}},244:(s,e,t)=>{const o=t(729),a=t(37),r=t(829);let{promisify:n}=t(23);const i=t(596),{createNotification:d}=(t(572),t(749),t(744));s.exports={getAllUsers:async(s,e)=>{try{const s=await i.find({}).populate(["favouriteBooks","posts"]).sort({createdAt:-1}).select(["-password","-confirmPassword"]);e.status(201).json({message:"Successfully fetched all the users",data:s})}catch(s){e.status(500).json({message:s.message})}},whoToFollow:async(s,e)=>{try{const t=s.user.id,o=await i.findById(t).select("following"),r=await i.aggregate([{$match:{_id:{$ne:new a.Types.ObjectId(t)}}},{$match:{_id:{$nin:o.following}}},{$sample:{size:6}}]);e.status(200).json({message:"Successfully fetched users to follow",data:r})}catch(s){e.status(500).json({message:s.message})}},getSingleUser:async(s,e)=>{try{const{id:t}=s.params,o=await i.findById(t).select(["-password","-confirmPassword"]).populate(["favouriteBooks","savedPosts","posts","followers","following"]);e.json(o)}catch(s){e.status(500).json({message:s.message})}},deleteUser:async(s,e)=>{const{id:t}=s.params;try{if(!await i.findByIdAndDelete(t))return e.status(404).json("Id Not Found");e.status(200).json("User Deleted Successfully")}catch(s){return e.status(500).json(s.message)}},updateUser:async(s,e)=>{try{const{id:t}=s.params,{name:o}=s.body,a=await i.findByIdAndUpdate(t,{name:o},{new:!0});a||e.status(404).json("No user with this Id found."),e.status(200).json({user:a})}catch(s){e.status(500).json("Error updating the User")}},searchByName:async(s,e)=>{try{const{name:t}=s.query,o=await i.find({name:t}).select(["-password","-confirmPassword"]);e.json(o)}catch(s){e.status(500).json({message:s.message})}},upToAdmin:async(s,e)=>{try{const{userId:t}=s.params,o=await i.findByIdAndUpdate(t,{role:"admin"},{new:!0}).select(["-password","-confirmPassword"]);o||e.status(404).json("No user with this Id found."),e.status(200).json({user:o})}catch(s){e.status(500).json("Error updating the User")}},downToUser:async(s,e)=>{try{const{userId:t}=s.params,o=await i.findByIdAndUpdate(t,{role:"user"},{new:!0}).select(["-password","-confirmPassword"]);o||e.status(404).json("No user with this Id found."),e.status(200).json({user:o})}catch(s){e.status(500).json("Error updating the User")}},filterWithUser:async(s,e)=>{try{const s=await i.find({role:"user"}).count();e.status(201).json({message:"Successfully fetched all the users",data:s})}catch(s){e.status(500).json({message:s.message})}},updateUserPhoto:async(s,e)=>{try{const{id:t}=s.params;let o="";null!=s.file&&(o=s.file.filename);const a=await i.findByIdAndUpdate(t,{photo:o},{new:!0});a||e.status(404).json("No user with this Id found."),e.status(200).json({user:a})}catch(s){e.status(500).json("Error updating the User")}},followUser:async(s,e)=>{try{const{userId:t,followUserId:o}=s.params;if(t===o)return e.status(400).json({message:"You cannot follow yourself"});const a=await i.findById(o);if(!a)return e.status(404).json({message:"User not found"});const r=await i.findById(t);if(!r)return e.status(404).json({message:"User not found"});if(r.following.includes(o))return e.status(400).json({message:"Already following this user"});r.following.push(o),await r.save(),a.followers.push(t),await a.save(),await d(t,o,"follow",`${r.name} followed you`),e.status(200).json({message:"Followed user successfully"})}catch(s){e.status(500).json({message:"Server error",error:s.message})}},unfollowUser:async(s,e)=>{const{userId:t,unfollowUserId:o}=s.params;if(!t||!o)return e.status(400).send("User IDs are required.");try{const s=await i.findById(t),a=await i.findById(o);if(!s||!a)return e.status(404).send("User not found.");s.following=s.following.filter((s=>s.toString()!==o)),a.followers=a.followers.filter((s=>s.toString()!==t)),await s.save(),await a.save(),e.status(200).send("Unfollowed successfully.")}catch(s){e.status(500).send("Server error.")}},profile:async(s,e)=>{try{console.log("hello");const{token:t}=s.cookies;if(!t)return e.status(404).json(null);let{data:{id:o}}=await n(r.verify)(t,process.env.SECRET_KEY);const a=await i.findById(o).populate(["favouriteBooks","savedPosts","following","followers"]);e.status(200).json(a)}catch(s){console.log("profile",s),e.status(400).json({error:s.message})}},updateProfile:async(s,e)=>{try{const t=s.user.id;console.log(t);const{bio:o}=s.body;console.log(s.files);let a={bio:o};s.files&&(s.files.photo&&(a.photo=`/userImages/${s.files.photo[0].filename}`),s.files.cover&&(a.cover=`/userImages/${s.files.cover[0].filename}`));const r=await i.findByIdAndUpdate(t,a,{new:!0});console.log(a),e.status(200).json({status:"success",data:{user:r}})}catch(s){e.status(500).json({status:"error",message:s.message})}},updateName:async(s,e)=>{const t=s.user.id,{name:o}=s.body;try{const s=await i.findById(t);if(!s)return e.status(404).json({msg:"User not found"});console.log(o,t),s.name=o,await s.save(),e.json({msg:"Name updated successfully",user:s})}catch(s){e.status(500).json({msg:"Server error",error:s})}},changePassword:async(s,e)=>{const t=s.user.id,{currentPassword:a,newPassword:r}=s.body;try{const s=await i.findById(t).select("+password").select("+confirmPassword");if(!s)return e.status(404).json({error:"User not found"});if(console.log(s.password),!await o.compare(a,s.password))return e.status(400).json({error:"Incorrect old password"});const n=await o.genSalt(10),d=await o.hash(r,n);s.password=d,s.password=d,await s.save(),e.json({message:"Password changed successfully"})}catch(s){e.status(500).json({error:"Server error"}),console.log(s.message,"ENd")}}}},536:(s,e,t)=>{const o=t(37),a=new o.Schema({name:{type:String,required:!0},books:[{type:o.Schema.Types.ObjectId,ref:"Book"}],description:{type:String},dateOfBirth:{type:Date,validate:{validator:function(s){return s<new Date}}},country:{type:String}});s.exports=o.model("Author",a)},878:(s,e,t)=>{const o=t(37),a=new o.Schema({authorId:{type:o.Schema.Types.ObjectId,ref:"Author",required:!0},title:{type:String,required:!0,unique:!0},description:{type:String},category:{type:String,required:!0},Pdf:{type:String},cover:{type:String},ratings:[{type:o.Schema.Types.ObjectId,ref:"Rating"}],averageRating:{type:Number,default:0},ratingCount:{type:Number,default:0}},{timestamps:!0}),r=o.model("Book",a);s.exports=r},424:(s,e,t)=>{const o=t(37),a=o.Schema,r=new a({userId:{type:a.Types.ObjectId,ref:"User",required:!0},description:{type:String,required:!0},likes:[{type:a.Types.ObjectId,ref:"User"}],postId:{type:a.Types.ObjectId,ref:"Post",required:!0}},{timestamps:!0}),n=o.model("Comment",r);s.exports=n},200:(s,e,t)=>{const o=t(37),a=new o.Schema({sender:{type:o.Schema.Types.ObjectId,ref:"User",required:!0},receiver:{type:o.Schema.Types.ObjectId,ref:"User",required:!0},type:{type:String,required:!0},message:{type:String,required:!0},isRead:{type:Boolean,default:!1}},{timestamps:!0}),r=o.model("Notification",a);s.exports=r},395:(s,e,t)=>{const o=t(37),a=new o.Schema({userId:{type:o.Schema.Types.ObjectId,required:!0,ref:"User"},description:{type:String,required:!0},type:{type:String,enum:["post","quote","review"],required:!0},imageURL:{type:String},book:{type:String},rating:{type:Number,min:0,max:5},likes:[{type:o.Schema.Types.ObjectId,ref:"User"}],comments:[{type:o.Schema.Types.ObjectId,ref:"Comment"}]},{timestamps:!0});s.exports=o.model("Post",a)},438:(s,e,t)=>{const o=t(37),a=new o.Schema({book:{type:o.Schema.Types.ObjectId,ref:"Book",required:!0},user:{type:o.Schema.Types.ObjectId,ref:"User",required:!0},rating:{type:Number,required:!0,min:1,max:5},review:{type:String,trim:!0}},{timestamps:!0}),r=o.model("Rating",a);s.exports=r},596:(s,e,t)=>{const o=t(37),a=t(906),r=t(749),n=new o.Schema({name:{type:String,required:!0},email:{type:String,required:!0,unique:!0,validate:[a.isEmail,"Invalid Email"],lowercase:!0},password:{type:String,required:!0,select:!1},photo:{type:String},cover:{type:String},bio:{type:String},posts:[{type:o.Schema.Types.ObjectId,ref:"Post"}],savedPosts:[{type:o.Schema.Types.ObjectId,ref:"Post"}],favouriteBooks:[{type:o.Schema.Types.ObjectId,ref:"Book"}],followers:[{type:o.Schema.Types.ObjectId,ref:"User"}],following:[{type:o.Schema.Types.ObjectId,ref:"User"}],notifications:[{type:o.Schema.Types.ObjectId,ref:"Notification"}],confirmPassword:{type:String,required:!0,select:!1},role:{type:String,enum:["admin","user"],default:"user"},passwordResetToken:String,passwordResetExpires:Date,loginTimestamps:[{type:Date}]},{timestamps:!0});n.methods.createPasswordResetToken=function(){const s=r.randomBytes(32).toString("hex");return this.passwordResetToken=r.createHash("sha256").update(s).digest("hex"),this.passwordResetExpires=Date.now()+6e5,s};const i=o.model("User",n);s.exports=i},391:(s,e,t)=>{const o=t(252),{createAuthor:a,getAuthor:r,deleteAuthor:n,getSingleAuthor:i,searchByName:d,updateAuthor:c}=t(284),u=o.Router();u.get("/",r),u.get("/:authorId",i),u.delete("/:authorId",n),u.post("/",a),u.get("/",d),u.patch("/:authorId",c),s.exports=u},489:(s,e,t)=>{const o=t(252),a=t(461),r=t(928),n=t(383),{getAllBook:i,addBook:d,searchByCategory:c,updateBook:u,deleteBook:l,getSingleBook:m,searchByTitle:p,addFavoriteBook:g,removeFavoriteBook:y,getAllCategory:f}=t(818),{auth:w}=t(617),h=a.diskStorage({destination:(s,e,t)=>{const o=r.join(__dirname,"../bookImage/");n.existsSync(o)||n.mkdirSync(o,{recursive:!0}),t(null,o)},filename:(s,e,t)=>{t(null,(new Date).toISOString().replace(/:/g,"-")+e.originalname)}}),I=a({storage:h}),j=o.Router();j.get("/",i),j.get("/categories",f),j.get("/searchCategory",c),j.get("/searchTitle",p),j.post("/",I.fields([{name:"Pdf",maxCount:1},{name:"cover",maxCount:1}]),d),j.get("/single/:id",m),j.post("/addFavoriteBook/:userId/:bookId",w,g),j.post("/removeFavoriteBook/:userId/:bookId",y),j.put("/:id",I.fields([{name:"Pdf",maxCount:1},{name:"cover",maxCount:1}]),u),j.delete("/:id",l),s.exports=j},944:(s,e,t)=>{const o=t(252).Router(),a=t(474);o.post("/",a.createComment),o.get("/",a.getAllComments),o.get("/post/:postId",a.getCommentsByPostId),o.put("/:commentId",a.updateComment),o.delete("/:commentId",a.deleteComment),o.post("/like/:commentId",a.likeComment),o.post("/unlike/:commentId",a.unlikeComment),s.exports=o},575:(s,e,t)=>{const o=t(252),a=t(744),r=o.Router();t(617),r.get("/:userId",a.getNotificationsForUser),r.put("/read-all/:userId",a.markNotificationsAsRead),r.post("/create",(async(s,e)=>{const{senderId:t,receiverId:o,type:r,message:n}=s.body;try{await a.createNotification(t,o,r,n),e.status(200).json({message:"Notification created successfully"})}catch(s){e.status(500).json({message:"Error creating notification",error:s.message})}})),r.delete("/:userId/:notificationId",a.deleteNotificationForUser),s.exports=r},751:(s,e,t)=>{const o=t(252),a=t(928),r=(t(383),o.Router()),n=t(617),i=t(117),d=t(461),c=d.diskStorage({destination:function(s,e,t){t(null,"postImages")},filename:function(s,e,t){t(null,Date.now()+"-"+Math.round(1e9*Math.random())+a.extname(e.originalname))}}),u=d({storage:c});r.post("/",u.single("image"),n.auth,i.createPost),r.get("/",i.getAllPosts),r.get("/pagination",i.getTwentyPostForPage),r.post("/like/:userId/:postId",i.likePost),r.post("/dislike/:userId/:postId",i.dislikePost),r.post("/save/:userId/:postId",i.savePost),r.post("/unsave/:userId/:postId",i.unSavePost),r.get("/:id",i.getUserPosts),r.get("/single/:id",i.getPostById),r.delete("/:id",i.deletePost),r.patch("/:id",u.single("photo"),i.updatePost),s.exports=r},857:(s,e,t)=>{const o=t(252).Router(),a=t(617),r=t(730);o.post("/:userId/:bookId",a.auth,a.restrictTo("admin","user"),r.addRating),o.get("/:id/reviews/first-five",r.getFirstFiveReviews),o.get("/:id/reviews/all",r.getAllReviews),o.delete("/:userId/:reviewId",r.deleteReview),s.exports=o},67:(s,e,t)=>{const o=t(252),a=t(461),r=t(928),n=t(383),{getAllUsers:i,deleteUser:d,getSingleUser:c,updateUser:u,searchByName:l,upToAdmin:m,downToUser:p,filterWithUser:g,updateUserPhoto:y,followUser:f,unfollowUser:w,profile:h,updateProfile:I,updateName:j,changePassword:v,whoToFollow:k}=t(244),S=t(617),P=a.diskStorage({destination:(s,e,t)=>{const o=r.join(__dirname,"../userImages");n.existsSync(o)||n.mkdirSync(o,{recursive:!0}),t(null,o)},filename:(s,e,t)=>{t(null,(new Date).toISOString().replace(/:/g,"-")+e.originalname)}}),B=a({storage:P}),U=o.Router();U.post("/login",S.login),U.post("/logout",S.logout),U.post("/register",S.signup),U.post("/forgotPassword",S.forgotPassword),U.post("/resetPassword/:token",S.resetPassword),U.post("/updatePassword",S.updatePassword),U.get("/single/:id",S.auth,c),U.get("/",i),U.get("/search",S.auth,l),U.patch("/up/:userId",m),U.patch("/down/:userId",S.auth,S.restrictTo("admin"),p),U.get("/user",S.auth,S.restrictTo("admin"),g),U.patch("/photo/:id",B.single("photo"),y),U.post("/follow/:userId/:followUserId",f),U.post("/unfollow/:userId/:unfollowUserId",w),U.get("/profile",S.auth,h),U.post("/google/auth",S.googleAuth),U.get("/:id",S.auth,c),U.route("/:id").delete(S.auth,S.restrictTo("admin","user"),d).patch(S.auth,S.restrictTo("admin","user"),u),U.get("/login/login-statistics",(async(s,e)=>{try{const s=await S.getLoginStatistics();e.status(200).json(s)}catch(s){e.status(500).json({msg:"Error retrieving login statistics",error:s})}})),U.get("/register/registerWeek/registration-statistics",(async(s,e)=>{try{const s=await S.getRegistrationStatistics();e.status(200).json(s)}catch(s){e.status(500).json({msg:"Error retrieving registration statistics",error:s})}})),U.get("/random/user/whoToFollow/timeline",S.auth,k),U.put("/updateProfile",S.auth,B.fields([{name:"photo",maxCount:1},{name:"cover",maxCount:1}]),I),U.put("/updatename",S.auth,j),U.put("/changepassword",S.auth,v),s.exports=U},702:s=>{s.exports=s=>(e,t,o)=>{s(e,t,o).catch(o)}},355:(s,e,t)=>{const o=t(572);s.exports=async s=>{console.log("hello");const e=o.createTransport({service:"gmail",host:"smtp.gmail.com",port:587,secure:!1,auth:{user:process.env.USER,pass:process.env.APP_PASSWORD}}),t={from:"booknet209@gmail.com",to:s.email,subject:s.subject,text:s.message},a=await e.sendMail(t);console.log("res",a)}},729:s=>{"use strict";s.exports=require("bcryptjs")},268:s=>{"use strict";s.exports=require("body-parser")},898:s=>{"use strict";s.exports=require("cookie-parser")},577:s=>{"use strict";s.exports=require("cors")},749:s=>{"use strict";s.exports=require("crypto")},437:s=>{"use strict";s.exports=require("dotenv")},252:s=>{"use strict";s.exports=require("express")},383:s=>{"use strict";s.exports=require("fs")},829:s=>{"use strict";s.exports=require("jsonwebtoken")},37:s=>{"use strict";s.exports=require("mongoose")},461:s=>{"use strict";s.exports=require("multer")},572:s=>{"use strict";s.exports=require("nodemailer")},685:s=>{"use strict";s.exports=require("request")},199:s=>{"use strict";s.exports=require("socket.io")},906:s=>{"use strict";s.exports=require("validator")},611:s=>{"use strict";s.exports=require("http")},928:s=>{"use strict";s.exports=require("path")},23:s=>{"use strict";s.exports=require("util")}},e={};function t(o){var a=e[o];if(void 0!==a)return a.exports;var r=e[o]={exports:{}};return s[o](r,r.exports,t),r.exports}const o=t(252),a=t(37),r=t(67),n=t(751),i=t(944),d=t(489),c=t(857),u=t(391),l=t(575),m=t(577),p=(t(437).config(),t(268)),g=t(898),y=t(200),f=t(744),w=o();w.use(o.json()),w.use(g()),w.use(p.json()),w.use(o.urlencoded({extended:!1})),w.use(m({credentials:!0,origin:"http://localhost:5173",methods:"GET,HEAD,PUT,PATCH,POST,DELETE"}));const h=t(611).createServer(w),I=t(199)(h,{cors:{origin:"http://localhost:5173",methods:["GET","POST"]}});f.initializeSocket(I),I.on("connection",(s=>{console.log("User connected",s.id),s.on("join",(e=>{console.log(`User ${s.id} joining room: ${e}`),s.join(e)})),s.on("leave",(e=>{console.log(`User ${s.id} leaving room: ${e}`),s.leave(e)})),s.on("disconnect",(()=>{console.log("User disconnected")}))})),w.post("/send-notification",(async(s,e)=>{const{userId:t,message:o,details:a}=s.body,r=new y({user:t,message:o,details:a});try{await r.save(),f.createNotification(null,t,"info",o),e.status(201).json(r)}catch(s){e.status(500).json({message:"Failed to save notification"})}})),a.connect(process.env.CONNECTION_DB,{}).then((()=>console.log("Connected to DB 😃"))).catch((s=>console.error("Failed to connect to DB",s))),w.use("/users",r),w.use("/posts",n),w.use("/comments",i),w.use("/books",d),w.use("/ratings",c),w.use("/authors",u),w.use("/notifications",l),w.use("/image",o.static("bookImage")),w.use("/userImages",o.static("userImages")),w.use("/postcard",o.static("postImages")),h.listen(process.env.PORT,(()=>console.log(`App listening on port ${process.env.PORT}!`)))})();